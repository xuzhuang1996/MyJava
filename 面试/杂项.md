## Java8新特性：
1. default接口
2. `::`，[双冒号](https://www.cnblogs.com/tietazhan/p/7486937.html)
3. lambda。都在Function包下。以及[流](https://blog.csdn.net/lidai352710967/article/details/82496783).注意：所有 Stream 的操作必须以 lambda 表达式为参数
4. [流stream的原理](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/)。这篇文章学习流必须看。
   1. 操作包括：
     - Intermediate：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered。Intermediate 操作永远是惰性化的。
     - Terminal：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator
     - Short-circuiting：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit
   2. 一次性使用。terminal操作之后无法再次进行terminal操作。
   3. 可以并行计算parallelStream。缺点是结果打乱之前顺序,以及线程安全问题。
   4. 注意：reduce(),如果没有设置初始种子，返回的是 Optional，也就是可能没有值进行reduce操作。而如果指定了初始值，就返回具体的对象 
4. Function接口：
   - [Function<T, R>，T—函数的输入类型，R-函数的输出类型。](https://www.orchome.com/935)lambda的写法就是Function内部写一个方法T为输入，使用的时候调用apply或者compose等就是相当于重写了该方法，获取返回。
   - 当然，对于需要重复使用的Function，可以事前定义好，像写函数一样，在具体使用的时候直接赋值。然后调用时直接用apply方法传参数就好了。
5. 流转数组

       Integer[] integers = Stream.of(1, 2, 3, 4, 5).toArray(Integer[]::new);
6. 转Map等

       employees.stream().collect(Collectors.toMap( e -> e.getEmpId(),  e -> e));
 
### ForkJoin
1. parallelStream底层使用该框架，将一个大任务拆分为很多小任务来异步执行。包含三个模块：
   1. 线程池ForkJoinPool,继承自AbstractExecutorService,
      
        <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/Thread/pool.png" width=100% height=100% />
   2. 任务对象ForkJoinTask,实现Future接口。
   3. 执行任务的线程ForkJoinWorkerThread，继承自Thread类。
2. 原理包括分治法以及工作窃取  
3. 案例：

         package com;

         import java.util.concurrent.ForkJoinPool;
         import java.util.concurrent.RecursiveTask;

         public class ForkJoin {
             public static void main(String[] args) {
                 ForkJoinPool forkJoinPool = new ForkJoinPool(); //创建一个线程池
                 SumTask sumTask = new SumTask(1, 100000000);  // 创建一个线程池
                 forkJoinPool.invoke(sumTask);  //提交任务
             }
         }

         // 创建一个求和的任务,该任务需继承RecursiveTask
         class SumTask extends RecursiveTask<Long> {
             //任务量拆分的临界值
             private long THRESHOLD = 3000L;
             //任务计算中的起始值跟结束值，比如计算3000到6000的值
             private long start = 0L;
             private long end = 0L;

             public SumTask(long start, long end) {
                 this.start = start;
                 this.end = end;
             }

             @Override
             protected Long compute() {
                 long len = end - start;

                 if (len > THRESHOLD){
                     //如果需要拆分,按2分法的方式进行拆分
                     long middle = (start + end) / 2;
                     SumTask left = new SumTask(start, middle);
                     left.fork();
                     SumTask right = new SumTask(middle + 1, end);
                     right.fork();

                     return left.join() + right.join();
                 }else{
                     //如果需要计算
                     return (end + start) * len / 2;
                 }
             }
         }

### Optional
1. 常见用法
   
         Optional<String> stringOptional = Optional.of("");
         stringOptional = Optional.empty();
         stringOptional.orElse(""); //如果stringOptional有值，就用自己的值，否则用orElse的值。泛型
         stringOptional.ifPresent(s -> System.out.println(s)); //与lambda的结合，如果有值就调用
         
         //在JDK1.9后改进了 Optional 类增加了 ifPresentOrElse 方法
         Optional.ofNullable(user).ifPresentOrElse(u -> {
            user.getName();
            user.getAge();
         }, () -> {
            System.err.println("user 对象为null");
         });
         
         //
         public String getUpperUserName2(Optional<User>op){
            String upperName=op. map(u->u.getUserName())
                              . map(s->s.toUpperCase())
                              . orE1se("null"); 
            return upperName;
          }
### 日期
1. 原先Date存在线程不安全等问题。现在使用LocalTime时分秒、LocalDate年月日、LocalDateTime具体时间
2. 相比之前，多了一些方法：
   
        LocalDate now = LocalDate.now();
        LocalDate localDate = LocalDate.of(2010, 1 ,1);
        now.isAfter(localDate); //时间的比较挺常用的
        now.isBefore(localDate);
        // 时间解析格式，有了自带的格式。但是LocalDate没有，需要自己解析
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE_TIME;
        String date = now.format(dtf); // 2019-12-09T18:48:13.14
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd"); // 或者自定义格式，注意时间方式MM月yyyy年dd天，都是有具体规范。线程安全
3. Duration计算时间的距离

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime end = LocalDateTime.now();
        Duration duration = Duration.between(now, end);
        duration.toDays(); // 相差的天数，这里LocalTime也可以
        duration.toHours();
4. Period计算日期的距离

        LocalDate now = LocalDate.now();
        LocalDate end = LocalDate.now();
        Period period = Period.between(now, end); // 后面时间-前面时间
        period.getMonths();
### Instant
1. 时间戳，用于处理1970.1.1 00:00:00以来的秒与纳秒

### 注解
1. 重复注解。一般注解不能在同一个地方使用多次相同注解。
   1. 定义重复注解容器
      
            @Retention(RetentionPolicy.RUNTIME)
            @interface MyTests{
               MyTest[] value();
            }
   2. 定义一个可以重复的注解
      
            @Retention(RetentionPolicy.RUNTIME)
            @Repeatable(MyTests.class)
            @interface MyTest{
               String value();
            }
1. 类型注解。JDK8为@Target元注解新增了两种类型：TYPE_PARAMTER、TYPE_USE：
   1. TYPE_PARAMTER表示该注解能写在类型参数的声明语句中，类型参数声明如<T>、<T extends Person>。
   
            @Target(ElementType.TYPE_PARAMETER)
            @interface MyType{
            }

            class MyTest<@MyType T>{
                public <@MyType E> void fun(){

                }
            }
   2. TYPE_USE表示注解可以在任何用到类型的地方使用
   
            @Target(ElementType.TYPE_USE)
            @interface NotNull{}

            public class Test {
                public static void main(String[] args) {
                    @NotNull int i = 0;
                }
            }
   
   
   
## Lambda系列
1. 前提：
   1. 方法的参数或者局部变量类型必须为接口。抽象类都不行
   2. 接口中有且仅有一个抽象方法
3. lambda例子

         //最初。匿名的内部类不能访问外部的索引值。如果只是一个值，没有修改过，那是可以访问的，但是如果修改过就不能使用，即需要final，即使不声明，也不能修改。
         ExecutorService executorService = Executors.newFixedThreadPool(10);
         for(int i = 0; i < 5; i++) {
           int temp = i;
           executorService.submit(new Runnable() {
             public void run() {
               //If uncommented the next line will result in an error
               //System.out.println("Running task " + i); 
               //local variables referenced from an inner class must be final or effectively final

               System.out.println("Running task " + temp); 
             }
           });
         }
         executorService.shutdown();
         
         //一次演变
         ExecutorService executorService = Executors.newFixedThreadPool(10)；            
         IntStream.range(0, 5)
          .forEach(i -> 
            executorService.submit(new Runnable() {
              public void run() {
                System.out.println("Running task " + i); 
              }
            }));
         executorService.shutdown();
         
         //二次演变
         IntStream.range(0, 5)
                  .forEach(i -> executorService.submit(() -> System.out.println("Running task " + i)));
                  
4. 将一个list中所有元素合在一起：不用reduce

         names.stream()
              .collect(Collectors.joining(", "))
              
5. 尽管lambda 表达式没有任何错误，但它的语法对于当前这个任务而言过于复杂。为了理解 (parameters) -> body 的用途，我们需要进入 body（在 -> 的右侧）来查看该形参发生了什么。如果该lambda表达式没有对该形参执行任何实际操作，则付出的努力就白费了。在此情况下，将传递 lambda 表达式替换为方法引用会比较有益。

         numbers.stream()
                .forEach(e -> System.out.println(e));
                
         numbers.stream()
                .forEach(System.out::println);
   如果 lambda 表达式的目的仅是将一个形参传递给实例方法，那么可以将它替换为实例上的方法引用
   
         e -> this.increment(e)
         this::increment
   如果传递表达式要传递给静态方法，可以将它替换为类上的方法引用
   
         e -> Integer.valueOf(e)
         Integer::valueOf
   如果形参是方法调用的目标,跟静态类似
   
         .map(e -> e.doubleValue())
         className::doubleValue
    一个构造函数调用
    
         .collect(toCollection(() -> new LinkedList<Double>()));
         .collect(toCollection(LinkedList::new));
    reduce传递2个参数的调用
    
         .reduce(0, (total, e) -> Integer.sum(total, e)));
         .reduce(0, Integer::sum));
6. lambda中闭包携带状态的方式是：闭包保留着 状态value 的一个副本

### lambda原理：
1. 实例：
   
            //目的接口，
            interface Swim{
                void fun();
            }
            public class Lambda {
                public static void main(String[] args) {
                    fun(() -> System.out.println("6"));
                }
                /**匿名内部类方式，
                fun(new Swim() {
                  @Override
                  public void fun() {
                      System.out.println("6");
                  }
                });**/
                
                public static void fun(Swim swim){
                    swim.fun();
                }
            }
2. lambda会在该类Lambda中生成一个私有静态方法，比如mian方法中第一次使用lambda：`lambda$main$0`，方法中的内容为lambda的表达式内容
     
              //javap -c -p C:\Users\wd\IdeaProjects\untitled\out\production\untitled\Lambda.class获取如下信息
              public class Lambda {
                 public Lambda();
                   Code:
                      0: aload_0
                      1: invokespecial #1                  // Method java/lang/Object."<init>":()V
                      4: return

                 public static void main(java.lang.String[]);
                   Code:
                      0: invokedynamic #2,  0              // InvokeDynamic #0:fun:()LSwim;
                      5: invokestatic  #3                  // Method fun:(LSwim;)V
                      8: return

                 public static void fun(Swim);
                   Code:
                      0: aload_0
                      1: invokeinterface #4,  1            // InterfaceMethod Swim.fun:()V
                      6: return

                 private static void lambda$main$0();
                   Code:
                      0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
                      3: ldc           #6                  // String 6
                      5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
                      8: return
               }
2. 然后在运行中动态生成一个内部类，实现目的接口Swim，并重写抽象方法，重写内容就是调用原先类新增的静态私有方法`Lambda.lambda$main$0();`。具体类生成方式：在`C:\Users\wd\IdeaProjects\untitled\out\production\untitled>`目录下执行命令：`java -Djdk.internal.lambda.dumpProxyClasses com.Lambda`,在正常的Java执行命令下加上这个参数，即可保存lambda动态生成的匿名内部类class数据到一个文件中。
    
            package com;
            import java.lang.invoke.LambdaForm.Hidden;

            // $FF: synthetic class
            final class Lambda$$Lambda$1 implements Swim {
                private Lambda$$Lambda$1() {
                }

                @Hidden
                public void fun() {
                    Lambda.lambda$main$0();
                }
            }




### RPC原理
1. 分布式部署后，各个系统相当于在不同机器上进行通信，因此需要解决相应的一些问题。

     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/面试/RPC.png" width=100% height=100% />

2. 常见框架：WebService、Thrift、Dubbo均基于TCP协议。而spring cloud是基于http协议的rest风格的RPC框架。
3. 手写一般就是：
   1. rpc框架，根据目的接口rpc-interface获取代理对象proxy，在rpc-client中直接调用该proxy对象的方法获取结果，实现远程调用。
   
            public class RpcProxy {
                /**
                 * 产生的对象调用目的接口方法时，最终会调用RpcInvokeHandler中的invoke方法。
                 */
                public <T> T getProxy(Class<T> classInterface){
                    // JDK的动态代理需要三个参数，获取目的接口的代理对象，需要传递T类型的Class对象。
                    return (T)Proxy.newProxyInstance(classInterface.getClassLoader(),
                            new Class[]{classInterface},
                            new RpcInvokeHandler());
                }
            }

   2. rpc-interface,目的接口
   3. rpc-client,调用的客户端。在rpc-client调用rpc-server实现的接口，并获取返回值。由于在不同项目中无法直接调用（JVM不同，例如spring运行环境不同，那么service注入的值也不同，导致获取结果不同，调用的目的是在rpc-server运行中的某个方法获取值），因此rpc-client调用proxy代理对象方法时会发出socket请求（在invoke方法中做的增强），待rpc-server处理完成后返回数据给rpc-client，这样就完成了远程调用.
   4. rpc-server,待调用的服务端。开启socket监听端口，接受rpc-client的请求，根据方法、参数反射调用目的接口，并返回数据。
5. 序列化在这里面的作用就是：rpc-client获取结果、rpc-server返回结果都需要序列化，并在传输层进行传输。
## 其他
7. [session\cookie](https://web.stanford.edu/~ouster/cgi-bin/cs142-fall10/lecture.php?topic=cookie)
   1. cookie
      - 浏览器第一次与特定服务器连接时，没有cookie。
      - 当服务器响应时,响应header中包含一个Set-Cookie。然后客户端保存Cookie,[实例](https://juejin.im/post/5aa783b76fb9a028d663d70a)
        
             Set-Cookie: logcookie=3qjj; expires=Wed, 13-Mar-2019 12:08:53 GMT; Max-Age=31536000; path=/;domain=fafa.com;secure; HttpOnly;
      - 每个cookie为<name,value>
      - 以后，每次浏览器连接同一个服务器时，请求header中都包含该cookie，服务器可以用这个cookie来连接相关请求。
   2. session
      - 服务器使用cookie来实现session。整个网站都需用户登录。
      - 用户第一次请求服务器,服务器创建识别用户的Session，然后把用户的认证状态与SessionID 绑定后记录在服务器端。请求返回时将此 Session 的唯一标识信息 SessionID 写入Set-Cookie返回给浏览器。


1. 实现：一套代码，用于线上环境+测试环境。maven提供了一种方便的解决这种问题的方案，就是profile功能
   1. 过滤器[Filter](https://www.runoob.com/w3cnote/filter-filterchain-filterconfig-intro.html)。在将代码代码部署到测试环境时就拿到了该测试服务器的maven的setting.xml，在里面人为定义机器的环境情况，于是pom.xml将调整为目的环境（在直接用[idea](https://www.jetbrains.com/help/idea/work-with-maven-profiles.html)开发的时候，可以点击右上角的maven，然后点击`m`按钮弹出命令框，输入`-P 您的配置文件的名称`，或者直接选择目标环境）。拿到对应环境的变量值，就可以赋值给web.xml中。在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。
   
            @Override
            public void init(FilterConfig filterConfig) throws ServletException {
                serverName = filterConfig.getInitParameter("serverName");//测试的网址，拿法跟isTest一样
                isTest = Boolean.parseBoolean(filterConfig.getInitParameter("isTest"));//是否为测试环境，从web.xml中拿，而web.xml从pom.xml中拿。而pom.xml的具体环境值根据profile确定
            }
   2. 然后在doFilter中根据地址来实现过滤
   
   
   
   
2. 注解。 java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。
   1. @Retention，注解的保留策略
      - @Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含
      - @Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，
      - @Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到
   2. @Target：定义注解的作用目标。修饰的对象范围
   3. @Document：说明该注解将被包含在javadoc中
   4. @Inherited：说明子类可以继承父类中的该注解
   5. 一般而言，注解只是相当于定义一个用于识别的符号，真正对被注解的对象起作用的是，针对注解做的开发，即凡是注解了该注解的类，都进行某种处理。一般由拦截器来实现处理


8. 序列化
   1. [来源](https://www.ibm.com/developerworks/cn/java/j-5things1/index.html)
   2. 序列化允许重构：将Person先序列化后存入文件。后面在Person中添加了一个字段后，将文件中的内容可以反序列化出来。前提是serialVersionUID字段相同。[IDEA创建serialVersionUID字段的方式](https://www.cnblogs.com/godtrue/p/7674487.html)
   3. 实例1
   
            public class Person implements java.io.Serializable{

                private static final long serialVersionUID = -8005239401998094343L;

                public Person(String fn, String ln, int a)
                {
                    this.firstName = fn; this.lastName = ln; this.age = a;
                }

                public String getFirstName() { return firstName; }
                public String getLastName() { return lastName; }
                public int getAge() { return age; }
                public Person getSpouse() { return spouse; }

                public void setFirstName(String value) { firstName = value; }
                public void setLastName(String value) { lastName = value; }
                public void setAge(int value) { age = value; }
                public void setSpouse(Person value) { spouse = value; }

                @Override
                public String toString()
                {
                    return "[Person: firstName=" + firstName +
                            " lastName=" + lastName +
                            " age=" + age +
                            " spouse=" + spouse.getFirstName() +
                            "]";
                }

                private String firstName;
                private String lastName;
                private int age;
                private Person spouse;
            }
            //序列化存入文件
            public class Main {
                public static void main(String[] args) {
                    Person ted = new Person("Ted", "Neward", 39);
                    Person charl = new Person("Charlotte", "Neward", 38);
                    ted.setSpouse(charl);
                    charl.setSpouse(ted);
                    try {
                        FileOutputStream fos = new FileOutputStream("tempdata.txt");
                        ObjectOutputStream oos = new ObjectOutputStream(fos);
                        oos.writeObject(ted);
                        oos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                 }
             }
             
   4. 实例2：现在给Person添加字段。然后反序列化出来
   
            enum Gender
            {
                MALE, FEMALE
            }

            public class Person implements java.io.Serializable{

                private static final long serialVersionUID = -8005239401998094343L;//这个值一定要跟之前的值一致

                public Person(String fn, String ln, int a, Gender g)
                {
                    this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;
                }

                public String getFirstName() { return firstName; }
                public String getLastName() { return lastName; }
                public Gender getGender() { return gender; }
                public int getAge() { return age; }
                public Person getSpouse() { return spouse; }

                public void setFirstName(String value) { firstName = value; }
                public void setLastName(String value) { lastName = value; }
                public void setGender(Gender value) { gender = value; }
                public void setAge(int value) { age = value; }
                public void setSpouse(Person value) { spouse = value; }

                @Override
                public String toString()
                {
                    return "[Person: firstName=" + firstName +
                            " lastName=" + lastName +
                            " gender=" + gender +
                            " age=" + age +
                            " spouse=" + spouse.getFirstName() +
                            "]";
                }

                private String firstName;
                private String lastName;
                private int age;
                private Person spouse;
                private Gender gender;//添加的字段
            }
            //反序列化读出文件的内容存到对象里面
            public class Main {
                public static void main(String[] args) {
                    try {
                        FileInputStream fis = new FileInputStream("tempdata.txt");
                        ObjectInputStream ois = new ObjectInputStream(fis);
                        Person tedNew = (Person) ois.readObject();
                        ois.close();
                        //输出[Person: firstName=Ted lastName=Neward gender=null age=39 spouse=Charlotte]
                        System.out.println(tedNew.toString());

                        new File("tempdata.txt").delete();
                    } catch (IOException | ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
            
            
            
1. [hashCode](https://www.ibm.com/developerworks/cn/java/j-5things3/index.html?ca=drs-)。支持哈希码的键依赖于可变字段的内容，这样容易产生 bug，解决：永远不要将可变对象类型用作 HashMap 中的键

         public static void main(String[] args) {
              Person p1 = new Person("Ted", "Neward", 39);
              Person p2 = new Person("Charlotte", "Neward", 38);
              System.out.println(p1.hashCode());

              Map<Person, Person> map = new HashMap<Person, Person>();
              map.put(p1, p2);
              p1.setLastName("Finkelstein");
              System.out.println(p1.hashCode());

              //将报错NPE：
              System.out.println(map.get(p1));
          }
2. hashmap的equal和hashcode为什么要同时重写:如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。
3. [海量数据查询:top K问题](https://blog.csdn.net/zyq522376829/article/details/47686867).例如：有1亿个浮点数，如果找出期中最大的10000个
   1. 单机+单核+足够大内存：如果有这么大内存，直接在内存中对查询次进行排序，顺序遍历找出10个出现频率最大的即可。
   2. 单机+多核+足够大内存：直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程按1处理。
   3. 单机+单核+受限内存：需要将原数据文件切割成一个一个小文件，直到每个小文件小于内存大小，依次处理每个任务
   4. 多机+受限内存：为了合理利用多台机器的资源，可将数据分发到多台机器上，按3处理。可采用hash+socket方法进行数据分发。采用Hash算法，将Hash值相同的数据交给同一个机器。
   
4. [CPU，主存，外设I/O读写速度不匹配的解决](https://www.iteye.com/blog/gengu-1165022)。
   1. 由于主存储器的访问速度与CPU执行指令的速度不一致，在计算机系统中引入了寄存器和高速缓存
   2. 由于I/O传输数据的速度远远低于CPU的执行熟读，在计算机系统中引入了缓冲区；另外就是中断方式处理
      - 1：缓和CPU与I/O设备间速度不匹配的矛盾。
      - 2：减少对CPU的中断操作，放宽对CPU中断响应时间的限制。
      - 3：提高CPU与I/O设备间的并行性，缓冲的引入可以显著的提高CPU和I/O设备间的并行操作程度，提高系统的吞吐量和设备的利用率。
     >1. 寄存器：寄存器能存一个数字，该数字的位数叫位宽，即64位；利用线路的矩阵实现具体数字的记录；一般寄存器存放操作数
     >2. 主存储器:用于存储进程运行时的程序和数据，可执行存储器，CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器读取并将他们装入到寄存器中
     >3. 内存RAM随时访问任何位置
5. 生产者消费者

         public  class Count {
             // 生产者在缓冲区满的时候会停，而缓冲区满的时候，此时需要信号量为0.因此需要一个变量notFull表示为0的时候缓冲区满
             static final Semaphore notFull = new Semaphore(2);
             // 当缓存区为0时，消费者拿不到消息，即为empty，每产生一个消息，都需要释放一个notEmpty，即缓存区产生一个数据
             static final Semaphore notEmpty = new Semaphore(0);
             // 互斥信号量,生产者产生后，由消费者消费，只是限制：在一个生产者工作过程中，消费者不能消费；或者消费者工作过程中不能生产
             static final Semaphore mutex = new Semaphore(1);
             //产生的数量
             private static Integer count = 0;
             public static void main(String[] args) {
                 Runnable producer = () -> {
                     try {
                         //首先判断是否有空位，可以让自己生产消息
                         notFull.acquire();
                         //同时还要现在是处于生产者工作时间
                         mutex.acquire();
                         count++;
                         System.out.println("生产者产生个数："+count);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }finally {
                         notEmpty.release();
                         mutex.release();
                     }
                 };
                 Runnable consumer = () -> {
                     try{
                         //判断是否不为空，这样才能消费
                         notEmpty.acquire();
                         //同时还要现在是处于生产者工作时间
                         mutex.acquire();
                         count--;
                         System.out.println("消费者消费后还剩个数：" + count);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }finally {
                         notFull.release();
                         mutex.release();
                     }
                 };

                 new Thread(producer).start();
                 new Thread(producer).start();
                 new Thread(producer).start();
                 new Thread(consumer).start();
                 new Thread(consumer).start();
                 new Thread(consumer).start();
             }
         }
1. prepareStament
   1. PreparedStatement只编译一次,而且防止SQL注入时，因为它会自动转义特殊字符.preparedStatement的一个限制是我们不能将它用于带有IN子句的SQL查询，因为PreparedStatement不允许我们为单个占位符（？）[绑定多个值](https://www.journaldev.com/2489/jdbc-statement-vs-preparedstatement-sql-injection-example)

           select name, country, password from Users where email = 'david@gmail.com\' or \'1\'=\'1\' and password=''
1. [限流](https://juejin.im/entry/5b4d8a8ce51d451908695590)
   1. 漏桶算法:准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。1000ms处理100个请求，则通过漏桶算法进行限流，每10毫秒处理一次请求。
1. [大数据排序](https://www.cnblogs.com/menghuizuotian/p/3840974.html):结合算法中的K链表合并方法
## Java语法最佳实践
1. [来源](https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz)
1. 频繁调用 Collection.contains 方法请使用 Set
   - List 的 contains 方法普遍时间复杂度是 O(n) ，如果在代码中需要频繁调用 contains 方法查找数据，可以先将 list 转换成 HashSet 实现，将 O(n) 的时间复杂度降为 O(1) 
   
         ArrayList<Integer> list = otherService.getList();
         Set<Integer> set = new HashSet(list);
         for (int i = 0; i <= Integer.MAX_VALUE; i++) {
             // 时间复杂度 O(1)
             set.contains(i);
         }
1. 建议使用 try-with-resources 语句.Java 7 中引入了 try-with-resources 语句，该语句能保证将相关资源关闭，优于原来的 try-catch-finally 语句
   - 反例
   
         private void handle(String fileName) {
             BufferedReader reader = null;
             try {
                 String line;
                 reader = new BufferedReader(new FileReader(fileName));
                 while ((line = reader.readLine()) != null) {
                     ...
                 }
             } catch (Exception e) {
                 ...
             } finally {
                 if (reader != null) {
                     try {
                         reader.close();
                     } catch (IOException e) {
                         ...
                     }
                 }
             }
          }
    - 正例
    
          private void handle(String fileName) {
             try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                 String line;
                 while ((line = reader.readLine()) != null) {
                     ...
                 }
             } catch (Exception e) {
                 ...
             }
          }
1. 禁止使用构造方法 BigDecimal(double),BigDecimal(double) 存在精度损失风险
   - 反例`BigDecimal value = new BigDecimal(0.1D); // 0.100000000000000005551115`
   - 正例`BigDecimal value = BigDecimal.valueOf(0.1D);; // 0.1`
1. 尽量返回空集合：`Collections.emptyList();`、`Collections.emptyMap();`
1. 小心 String.split(String regex)，传入的分隔字符串是正则表达式！部分关键字（比如.| 等）需要转义
   - 反
   
         "a.ab.abc".split("."); // 结果为 []
         "a|ab|abc".split("|"); // 结果为 ["a", "|", "a", "b", "|", "a", "b", "c"]
   - 正
   
         "a.ab.abc".split("\\."); // 结果为 ["a", "ab", "abc"]
         "a|ab|abc".split("\\|"); // 结果为 ["a", "ab", "abc"]


## MyBatis
1. [来源](https://tech.meituan.com/2018/01/19/mybatis-cache.html)
1. 一级缓存
   - 默认Session级别，在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。
   - Statement级别,缓存只对当前执行的这一个有效
   - 一级缓存的生命周期和SqlSession一致
   - 一级缓存内部设计简单，只是一个没有容量限定的HashMap
   - 一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。
2. 二级缓存
   1. MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享
   2. MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。
   3. 在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据
