## redis

1. redis快，基于内存，单线程，基于resp协议。可以将mysql中的数据，根据select语句做管道输入，将数据转入redis。
2. 数据类型：
   - String
     - `SET name "runoob"`
     - `GET name`
   - Hash,适合存储对象
     - `HMSET myhash field1 "Hello" field2 "World"`
     - `HGET myhash field1`
   - List,增删快
     - `lpush runoob redis`
     - `lpush runoob mongodb`
     - `lrange runoob 0 10`    //取值
   - Set,添加、删除,查找的复杂度都是O(1),为集合提供了求交集、并集、差集等操作。内部使用Hash结构，所有的value都指向同一个内部值。
     - `sadd runoob mongodb`   //添加
     - `smembers runoob`    //取值
   - zset(sorted set：有序集合)，不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
     - `zadd runoob 0 redis`
     - `ZRANGEBYSCORE runoob 0 1000`
3. [zset底层](https://lijh.dev/2019/03/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-Zset%E5%8E%9F%E7%90%86/)：Hash+[跳表](https://juejin.im/post/57fa935b0e3dd90057c50fbc)
   - Hash作用：保障元素value的唯一性,可以通过元素value找到相应的score权重值。
   - 跳跃列表的目的在于根据score给元素value排序，即输出为有序集合。

    <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/面试/skiplist.png" width=50% height=50% />
4. 跳表特点
   1. 在有序链表的基础上发展起来，最初想模仿二分法查找的方式来使查找时间复杂度为O(log n)。但是新插入一个节点之后，就会打乱原先的链表指针对应关系。
   2. 为了避免这个问题，为每个节点随机出一个层数，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这样新插入一个节点不会影响其它节点
   3. 不选择树：
      - 它们的内存不是很大。
      - 效率几乎一样
      - 更容易实现，调试

### redis做消息队列
1. 通过2个命令实现pub/sub模式的消息通知
   - `publish 主题名称 消息内容`,向指定主题发送一条消息
   - `subscribe 主题名称`,订阅某一主题。
2. key失效的时候会发送一些通知，可以通过订阅某一个主题，接受key失效的消息通知（此通知是redis内部事件处理机制）
   - 首先开启事件通知，修改redis启动的配置文件：安装目录下的redis.windows.conf，查找到`notify-keyspace-events Ex`，取消其注释，然后重启redis服务器。
   - 接着，需要订阅的主题名称：`__keyevent@dbindex__:expired`。例子：存储到的redis服务器是0号数据库，则订阅命令为` subscribe __keyevent@0__:expired`，然后测试`set keyName "xu"`,`expire keyName 5`设置其5秒后过期，`ttl keyName`查看其剩余时间。
    >不过很遗憾，我修改配置文件并没有生效，而是运行命令`config set notify-keyspace-events Ex`才可以



### redis为何那么快
1. redis是基于内存的，一般都是简单的存取操作，内存的读写速度非常快
2. redis是单线程的，省去了很多上下文切换线程的时间，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
    
    >官方FAQ表示：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了
3. redis使用非阻塞I/O多路复用技术，可以处理并发的连接
   - 多路，指的是多个socket连接
   - 复用，指的是复用一个线程

    [Redis-client 在操作的时候](https://zhuanlan.zhihu.com/p/50392209)，会产生具有不同事件类型的 Socket。在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。
   
    >Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信


### 过期数据的删除对 Redis 性能影响

1. [定时删除](https://zhuanlan.zhihu.com/p/57089960)：在设置键过期expire时间的同时，创建一个定时器 Timer，让定时器在键过期时间来临时立即执行对过期键的删除。
   - 对内存友好，对 CPU 不友好。如果过期删除的键比较多的时候，删除键这一行为会占用相当一部分 CPU 性能，会对 Redis 的吞吐量造成一定影响
2. 惰性删除：键过期后不管，每次读取该键时，判断该键是否过期，如果过期删除该键返回空。
   - 对 CPU 友好，内存不友好。如果很多键过期了，但在将来很长一段时间内没有很多客户端访问该键导致过期键不会被删除，占用大量内存空间。
3. 定期删除：每隔一段时间对数据库中的过期键进行一次检查。
   - Redis 会将每一个设置了 expire 的键存储在一个独立的字典中，以后会定时遍历这个字典来删除过期的 key。除了定时遍历外，它还会使用惰性删除策略来删除过期的 key。
   - Redis 默认每秒进行十次过期扫描，过期扫描不会扫描所有过期字典中的 key，而是采用了一种简单的贪心策略:从过期字典中随机选择 20 个 key；删除这 20 个 key 中已过期的 key；如果过期 key 比例超过 1/4，那就重复步骤一
   - 同时，为了保证在过期扫描期间不会出现过度循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过 25ms
4. 定期删除+惰性删除。如果定期删除没删除掉 Key。并且你也没及时去请求 Key，也就是说惰性删除也没生效。这样，Redis 的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf文件中，`# maxmemory-policy volatile-lru`用于配内存淘汰策略.其中比较推荐的一种是：allkeys-lru，当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key

### 如何应对缓存穿透和缓存雪崩问题
1. 缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
   - 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。
2. 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
   - 给缓存的失效时间，加上一个随机值，避免集体失效。
   - 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为20分钟，缓存 B 不设失效时间。自己做缓存预热操作。例如：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。
   
### 分布式锁
1. 分布式系统中，由于分布式系统的分布性，即多线程和多进程并且分布在不同机器中，synchronized和lock这两种锁将失去原有锁的效果，需要我们自己实现分布式锁。
2. 条件：
   - 互斥性：在任意一个时刻，只有一个客户端持有锁
   - 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
   - 容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁
   
3. 基于redis的分布式锁实现
   - SETNX
      - [多个进程执行以下Redis命令](https://juejin.im/entry/5a502ac2518825732b19a595)`SETNX lock.id <current Unix time + lock timeout + 1>`:
	    - 返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。
	    - 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。
		   
      
      存在问题：死锁。某个线程获取了锁之后，断开了与Redis 的连接，锁没有及时释放，竞争该锁的其他线程都会hung，产生死锁的情况。于是才设置的时间。但有另外的问题，离线超时后未释放，其他进程中的线程怎么获取，直接del肯定不行，容易重复del.
   - GETSET
     - A已经首先获得了锁 lock.id，然后A断线。B,C都在等待竞争该锁；
     - B,C通过GET读取lock.id的值，比较当前时间和键 lock.id 的值来判断是否超时，发现超时；
     - B检测到锁已超时，即当前的时间大于键 lock.id 的值，B会执行`GETSET lock.id <current Unix timestamp + lock timeout + 1>`设置时间戳，通过比较键 lock.id 的旧值是否小于当前时间，判断进程是否已获得锁；
     - B发现GETSET返回的值小于当前时间，则执行 DEL lock.id命令，并执行 SETNX lock.id 命令，并返回1，B获得锁；
     - C执行GETSET得到的时间大于当前时间，则继续等待。
	  
   
    解决问题：BC同时发现超时,即BC均GET到key的时间，均大于这个时间，同时去执行GETSET，试图比较返回值与自己GET到的值，如果返回值比自己GET到的值大，说明别的线程已修改，相等，则说明还没有人拿到锁。
     >`SETNX key value`若给定的 key 已经存在，则 SETNX 不做任何动作。SET if Not eXists。设置成功，返回 1 。设置失败，返回 0 。   
     >`GETSET key value`:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。

### redis集群：有3个主节点，每个主节点都有一个从节点作为备用。节点间交换通过Gossip协议
1. 原理：集群里面的槽总共有16384个，根据节点的个数进行平均分配。分配完后各个节点向其他节点发送数据，这样就知道各个节点负责哪些槽。然后就可以用了。
2. 存取：随机在一个节点执行set操作，该节点使用crc16算法对key计算得哈希值，然后对16384求余，判断余数在哪个节点，然后直接自动跳转到这个对应的节点上进行存取操作。
3. 投票：当一台主节点掉线时，集群中其他的主节点将会通过投票的形式在掉线主结点的从结点中选举一台从节点来代替原先的主节点，并更改剩余从节点slave的主节点为新的主节点。即所有master参与,如果半数以上master节点与master节点通信超时。
4. fail：
   - 如果集群任意master挂掉,且当前master没有slave.集群进入fail状态
   - 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态.
5. 哨兵模式。哨兵是一个独立的进程，哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例：
   - 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
   - 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

### 一致性哈希算法
1. [来源](https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368):本来是通过`hash(a.png) % 4 = 2`来找到对象存放的服务器，但当分布式服务器中有的坏掉或者新增，则不再是对4进行取模导致结果跟之前不一样。由于哈希数值上是0-2^32，因此一致性Hash算法是对2^32取模。由2^32个点组成的圆环称为Hash环。接着确定各个服务器在圆环的位置，最后，将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！
2. 一致性Hash算法的容错性和可扩展性：
   - 现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响
   - 如果在系统中增加一台服务器Node X
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/面试/pp.png" width=50% height=50% />

3. 问题：一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：

    <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/面试/ppp.png" width=50% height=50% />
4. 然而redis并没有使用一致性哈希，文档自己说的。[原因的话](https://zackku.com/redis-cluster/):一致性哈希算法对于数据分布、节点位置的控制并不是很友好
   1. Redis Cluster包含了16384个哈希槽，每个Key通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。
   2. 在容错性和扩展性上(添加或故障删除节点)，都是对受影响的数据进行转移，但Redis集群是不会自动进行的，而是需要人工配置的。
   
### 主从复制
https://juejin.im/post/5b625b9be51d4519956759d0


### 持久化

### 哨兵机制
1. [redis使用哨兵机制来实现高可用](https://www.codedump.info/post/20190409-redis-sentinel/)
   - redis使用一组哨兵（sentinel）节点来监控主从redis服务的可用性
   - 一旦发现redis主节点失效，将选举出一个**哨兵节点**作为领导者
   - 哨兵领导者再从剩余的从redis节点中选出一个redis节点作为新的主redis节点对外服务
2. 如何对redis数据节点进行监控：每隔10秒，每个哨兵节点都会向主、从redis数据节点发送info命令，获取新的拓扑结构信息（本节点角色：主或从；主从节点的地址、端口信息）
3. 如何确定一个redis数据节点失效：每隔1秒，每个哨兵节点向主、从数据节点以及其他sentinel节点发送ping命令做心跳探测，这个心跳探测是后续主观判断数据节点下线的依据;当一个哨兵节点认为主节点主观下线时，该哨兵节点需要通过”sentinel is-master-down-by addr”命令向其他哨兵节点咨询该主节点是否下线了，如果有超过半数的哨兵节点都回答了下线，此时认为主节点“客观下线”。
4. 当主节点客观下线时，需要选举出一个哨兵节点做为哨兵领导者，以完成后续选出新的主节点的工作:
   - 每个哨兵节点通过向其他哨兵节点发送”sentinel is-master-down-by addr”命令来申请成为哨兵领导者
   - 而每个哨兵节点在收到一个”sentinel is-master-down-by addr”命令时，只允许给第一个节点投票，其他节点的该命令都会被拒绝
   - 如果一个哨兵节点收到了半数以上的同意票，则成为哨兵领导者
5. 选出新的主节点:过滤掉“不健康”的数据节点;选择复制偏移量最大的从节点。
